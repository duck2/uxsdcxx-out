#include <bitset>
#include <cassert>
#include <cstring>
#include <iostream>
#include <limits>
#include <memory>
#include <string>
#include <vector>

#include <error.h>
#include <stddef.h>
#include <stdint.h>
#include "pugixml.hpp"

/*
 * This file is generated by uxsdcxx.
 * Modify only if your build process doesn't involve regenerating this file.
 *
 * Cmdline: ./uxsdcxx.py rr_graph.xsd
 * Input file: rr_graph.xsd
 * md5sum of input file: 2b7bc77a1e7c006250cf0351f8046f9e
 */

/* All uxsdcxx functions and structs live in this namespace. */
namespace uxsd {

typedef const uint32_t __attribute__((aligned(1))) triehash_uu32;
typedef const uint64_t __attribute__((aligned(1))) triehash_uu64;
static_assert(alignof(triehash_uu32) == 1, "Unaligned 32-bit access not found.");
static_assert(alignof(triehash_uu64) == 1, "Unaligned 64-bit access not found.");
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#define onechar(c, s, l) (((uint64_t)(c)) << (s))
#else
#define onechar(c, s, l) (((uint64_t)(c)) << (l-8-s))
#endif


/* Stores a vector of elements in a shared pool. Consists
 * of an offset into the pool and a size. It's faster than a regular
 * vector, but one can only insert into it when it's the last vector
 * in the pool. */
template<class T, std::vector<T> &pool>
class collapsed_vec {
private:
	uint32_t _size;
	uint32_t _offset;
public:
	inline collapsed_vec(){
		_size = 0;
		_offset = pool.size();
	}
	inline T& back(){
		return pool[_offset+_size-1];
	}
	inline T* begin(){
		return &pool[_offset];
	}
	inline T* end(){
		return &pool[_offset+_size];
	}
	inline T& operator[](uint32_t i){
		return pool[_offset+i];
	}
	inline void push_back(const T &x){
		assert(_size+_offset == pool.size());
		pool.push_back(x);
		_size++;
	}
	inline uint32_t size(){
		return _size;
	}
};

/* A pool of strings. It exposes an add(const char *x) function
 * which is like a better strdup.
 * add() calls strlen on the argument to see how much space is needed.
 * Then it checks its vector of chunks to see if there is a chunk it
 * would fit into. If none is found, a new one is allocated with a size of
 * max(length of string, last chunk's size*2). */
class string_pool_impl {
private:
	const uint32_t INITIAL_SIZE = 1024;
	struct chunk {
		uint32_t used;
		uint32_t size;
		char * mem;
	};
	std::vector<chunk> chunks;
public:
	string_pool_impl(){
		chunk c;
		c.used = 0;
		c.size = INITIAL_SIZE;
		c.mem = (char *)std::malloc(INITIAL_SIZE);
		chunks.emplace_back(c);
	}
	~string_pool_impl(){
		for(auto &c: chunks)
			free(c.mem);
	}
	const char *add(const char *x){
		uint32_t len = std::strlen(x)+1;
		char *out;
		for(auto &c: chunks){
			if(c.used+len <= c.size){
				out = &c.mem[c.used];
				c.used += len;
				std::memcpy(out, x, len);
				return out;
			}
		}
		chunk n;
		n.used = 0;
		n.size = std::max(chunks.back().size*2, len);
		n.mem = (char *)std::malloc(n.size);
		std::memcpy(n.mem, x, len);
		chunks.emplace_back(n);
		return n.mem;
	}
	void clear(){
		for(int i=1; i<chunks.size(); i++){
			free(chunks[i].mem);
		}
		chunks.resize(1);
		chunks[0].used = 0;
		std::memset(chunks[0].mem, 0, INITIAL_SIZE);
	}
};
/* Forward decl of generated data types. Needed for the pools. */
struct t_channel;
struct t_x_list;
struct t_y_list;
struct t_timing;
struct t_sizing;
struct t_segment_timing;
struct t_pin;
struct t_meta;
struct t_grid_loc;
struct t_node_loc;
struct t_node_timing;
struct t_node_segment;
struct t_bin_nodes;
struct t_connection_box;
struct t_switch;
struct t_segment;
struct t_pin_class;
struct t_metadata;
struct t_channels;
struct t_grid_locs;
struct t_connection_boxes;
struct t_block_type;
struct t_node;
struct t_edge;
struct t_switches;
struct t_segments;
struct t_block_types;
struct t_rr_nodes;
struct t_rr_edges;
struct t_rr_graph;

/* Global shared pools for storing multiply-occurring elements. */
extern std::vector<t_pin> pin_pool;
extern std::vector<t_meta> meta_pool;
extern std::vector<t_pin_class> pin_class_pool;
extern std::vector<t_x_list> x_list_pool;
extern std::vector<t_y_list> y_list_pool;
extern std::vector<t_switch> switch_pool;
extern std::vector<t_segment> segment_pool;
extern std::vector<t_block_type> block_type_pool;
extern std::vector<t_grid_loc> grid_loc_pool;
extern std::vector<t_node> node_pool;
extern std::vector<t_edge> edge_pool;
extern std::vector<t_connection_box> connection_box_pool;

extern string_pool_impl string_pool;


/* Helper function for freeing the pools. */
void clear_pools(void);

/* One may want to use the allocated strings after loading, so this
 * function is provided separately.
void clear_string_pool(void);

/* Data type defns generated from the XSD schema. */
enum class enum_switch_type {UXSD_INVALID = 0, MUX, TRISTATE, PASS_GATE, SHORT, BUFFER};
enum class enum_pin_type {UXSD_INVALID = 0, OPEN, OUTPUT, INPUT};
enum class enum_loc_side {UXSD_INVALID = 0, LEFT, RIGHT, TOP, BOTTOM};
enum class enum_node_type {UXSD_INVALID = 0, CHANX, CHANY, SOURCE, SINK, OPIN, IPIN};
enum class enum_node_direction {UXSD_INVALID = 0, INC_DIR, DEC_DIR, BI_DIR};

struct t_channel {
	int chan_width_max;
	int x_min;
	int y_min;
	int x_max;
	int y_max;
};
struct t_x_list {
	unsigned int index;
	int info;
};
struct t_y_list {
	unsigned int index;
	int info;
};
struct t_timing {
	float R;
	float Cin;
	float Cinternal;
	float Cout;
	float Tdel;
};
struct t_sizing {
	float mux_trans_size;
	float buf_size;
};
struct t_segment_timing {
	float R_per_meter;
	float C_per_meter;
};
struct t_pin {
	int ptc;
	const char * value;
};
struct t_meta {
	const char * name;
	const char * value;
};
struct t_grid_loc {
	int x;
	int y;
	int block_type_id;
	int width_offset;
	int height_offset;
};
struct t_node_loc {
	int xlow;
	int ylow;
	int xhigh;
	int yhigh;
	enum_loc_side side;
	int ptc;
};
struct t_node_timing {
	float R;
	float C;
};
struct t_node_segment {
	int segment_id;
};
struct t_bin_nodes {
	const char * file;
};
struct t_connection_box {
	int id;
	const char * name;
};
struct t_switch {
	int id;
	const char * name;
	enum_switch_type type;
	bool has_timing;
	t_timing timing;
	t_sizing sizing;
};
struct t_segment {
	int id;
	const char * name;
	bool has_timing;
	t_segment_timing timing;
};
struct t_pin_class {
	enum_pin_type type;
	collapsed_vec<t_pin, pin_pool> pins;
};
struct t_metadata {
	collapsed_vec<t_meta, meta_pool> metas;
};
struct t_channels {
	t_channel channel;
	collapsed_vec<t_x_list, x_list_pool> x_lists;
	collapsed_vec<t_y_list, y_list_pool> y_lists;
};
struct t_grid_locs {
	collapsed_vec<t_grid_loc, grid_loc_pool> grid_locs;
};
struct t_connection_boxes {
	int x_dim;
	int y_dim;
	int num_boxes;
	collapsed_vec<t_connection_box, connection_box_pool> connection_boxes;
};
struct t_block_type {
	int id;
	const char * name;
	int width;
	int height;
	collapsed_vec<t_pin_class, pin_class_pool> pin_classes;
};
struct t_node {
	unsigned int id;
	enum_node_type type;
	enum_node_direction direction;
	unsigned int capacity;
	t_node_loc loc;
	bool has_timing;
	t_node_timing timing;
	bool has_segment;
	t_node_segment segment;
	bool has_metadata;
	t_metadata metadata;
};
struct t_edge {
	unsigned int id;
	unsigned int src_node;
	unsigned int sink_node;
	unsigned int switch_id;
	bool has_metadata;
	t_metadata metadata;
};
struct t_switches {
	collapsed_vec<t_switch, switch_pool> switches;
};
struct t_segments {
	collapsed_vec<t_segment, segment_pool> segments;
};
struct t_block_types {
	collapsed_vec<t_block_type, block_type_pool> block_types;
};
struct t_rr_nodes {
	collapsed_vec<t_node, node_pool> nodes;
};
struct t_rr_edges {
	collapsed_vec<t_edge, edge_pool> edges;
};
struct t_rr_graph {
	const char * tool_name;
	const char * tool_version;
	const char * tool_comment;
	bool has_binary_nodes_and_edges;
	t_bin_nodes binary_nodes_and_edges;
	bool has_connection_boxes;
	t_connection_boxes connection_boxes;
	t_channels channels;
	t_switches switches;
	t_segments segments;
	t_block_types block_types;
	t_grid_locs grid;
	t_rr_nodes rr_nodes;
	t_rr_edges rr_edges;
};

class rr_graph : public t_rr_graph {
public:
	pugi::xml_parse_result load(std::istream &is);
	void write(std::ostream &os);
};

/* Loading functions. They validate the DOM data
 * and load it into the generated structures. */
void load_channel(const pugi::xml_node &root, t_channel *out);
void load_x_list(const pugi::xml_node &root, t_x_list *out);
void load_y_list(const pugi::xml_node &root, t_y_list *out);
void load_timing(const pugi::xml_node &root, t_timing *out);
void load_sizing(const pugi::xml_node &root, t_sizing *out);
void load_segment_timing(const pugi::xml_node &root, t_segment_timing *out);
void load_pin(const pugi::xml_node &root, t_pin *out);
void load_meta(const pugi::xml_node &root, t_meta *out);
void load_grid_loc(const pugi::xml_node &root, t_grid_loc *out);
void load_node_loc(const pugi::xml_node &root, t_node_loc *out);
void load_node_timing(const pugi::xml_node &root, t_node_timing *out);
void load_node_segment(const pugi::xml_node &root, t_node_segment *out);
void load_bin_nodes(const pugi::xml_node &root, t_bin_nodes *out);
void load_connection_box(const pugi::xml_node &root, t_connection_box *out);
void load_switch(const pugi::xml_node &root, t_switch *out);
void load_segment(const pugi::xml_node &root, t_segment *out);
void load_pin_class(const pugi::xml_node &root, t_pin_class *out);
void load_metadata(const pugi::xml_node &root, t_metadata *out);
void load_channels(const pugi::xml_node &root, t_channels *out);
void load_grid_locs(const pugi::xml_node &root, t_grid_locs *out);
void load_connection_boxes(const pugi::xml_node &root, t_connection_boxes *out);
void load_block_type(const pugi::xml_node &root, t_block_type *out);
void load_node(const pugi::xml_node &root, t_node *out);
void load_edge(const pugi::xml_node &root, t_edge *out);
void load_switches(const pugi::xml_node &root, t_switches *out);
void load_segments(const pugi::xml_node &root, t_segments *out);
void load_block_types(const pugi::xml_node &root, t_block_types *out);
void load_rr_nodes(const pugi::xml_node &root, t_rr_nodes *out);
void load_rr_edges(const pugi::xml_node &root, t_rr_edges *out);
void load_rr_graph(const pugi::xml_node &root, t_rr_graph *out);

void dfa_error(const char *wrong, int *states, const char **lookup, int len);
template<std::size_t N>
void all_error(std::bitset<N> gstate, const char **lookup);
template<std::size_t N>
void attr_error(std::bitset<N> astate, const char **lookup);
} /* namespace uxsd */
