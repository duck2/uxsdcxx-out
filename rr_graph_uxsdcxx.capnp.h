// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: rr_graph_uxsdcxx.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 7000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(b311a262804a5cbe);
enum class SwitchType_b311a262804a5cbe: uint16_t {
  MUX,
  TRISTATE,
  PASS_GATE,
  SHORT,
  BUFFER,
};
CAPNP_DECLARE_ENUM(SwitchType, b311a262804a5cbe);
CAPNP_DECLARE_SCHEMA(dc914bbe8a95266b);
enum class PinType_dc914bbe8a95266b: uint16_t {
  OPEN,
  OUTPUT,
  INPUT,
};
CAPNP_DECLARE_ENUM(PinType, dc914bbe8a95266b);
CAPNP_DECLARE_SCHEMA(efb1054accd89b10);
enum class LocSide_efb1054accd89b10: uint16_t {
  LEFT,
  RIGHT,
  TOP,
  BOTTOM,
};
CAPNP_DECLARE_ENUM(LocSide, efb1054accd89b10);
CAPNP_DECLARE_SCHEMA(cbae9f794b4e7828);
enum class NodeType_cbae9f794b4e7828: uint16_t {
  CHANX,
  CHANY,
  SOURCE,
  SINK,
  OPIN,
  IPIN,
};
CAPNP_DECLARE_ENUM(NodeType, cbae9f794b4e7828);
CAPNP_DECLARE_SCHEMA(f6bb46baa2f38621);
enum class NodeDirection_f6bb46baa2f38621: uint16_t {
  INC_DIR,
  DEC_DIR,
  BI_DIR,
};
CAPNP_DECLARE_ENUM(NodeDirection, f6bb46baa2f38621);
CAPNP_DECLARE_SCHEMA(8281fc5fbc1ea1ce);
CAPNP_DECLARE_SCHEMA(9a64dad11eeb08ba);
CAPNP_DECLARE_SCHEMA(836f0f2555113268);
CAPNP_DECLARE_SCHEMA(818068b4395469e9);
CAPNP_DECLARE_SCHEMA(c3bca30e882428a5);
CAPNP_DECLARE_SCHEMA(b553ce463639a60b);
CAPNP_DECLARE_SCHEMA(d95894a0bc8ca56d);
CAPNP_DECLARE_SCHEMA(adb5d2318fc1539f);
CAPNP_DECLARE_SCHEMA(f929c136e3d37192);
CAPNP_DECLARE_SCHEMA(ab4c09b13574bfce);
CAPNP_DECLARE_SCHEMA(951bee909a9d3d16);
CAPNP_DECLARE_SCHEMA(b19cff100e3ab2bb);
CAPNP_DECLARE_SCHEMA(ff25f299dad5c8f5);
CAPNP_DECLARE_SCHEMA(ab54b0e5ced07cb0);
CAPNP_DECLARE_SCHEMA(b680b4b9c81fad46);
CAPNP_DECLARE_SCHEMA(bde08ceb25928e34);
CAPNP_DECLARE_SCHEMA(ba73370bd56eda71);
CAPNP_DECLARE_SCHEMA(c6833636198c9030);
CAPNP_DECLARE_SCHEMA(f9804e6682a46e90);
CAPNP_DECLARE_SCHEMA(a156231d89499253);
CAPNP_DECLARE_SCHEMA(98525d6e2fe65138);
CAPNP_DECLARE_SCHEMA(961742a65e1df39a);
CAPNP_DECLARE_SCHEMA(a38f0d830ee56ae4);
CAPNP_DECLARE_SCHEMA(ff494c402e780f12);
CAPNP_DECLARE_SCHEMA(b8fa642c9d0c2b0f);
CAPNP_DECLARE_SCHEMA(9aa36e608dbaa408);
CAPNP_DECLARE_SCHEMA(bddada96d2721e78);
CAPNP_DECLARE_SCHEMA(f3fb1e46a7505145);
CAPNP_DECLARE_SCHEMA(abcefd01f55032dd);
CAPNP_DECLARE_SCHEMA(ddca876b31278662);

}  // namespace schemas
}  // namespace capnp


typedef ::capnp::schemas::SwitchType_b311a262804a5cbe SwitchType;

typedef ::capnp::schemas::PinType_dc914bbe8a95266b PinType;

typedef ::capnp::schemas::LocSide_efb1054accd89b10 LocSide;

typedef ::capnp::schemas::NodeType_cbae9f794b4e7828 NodeType;

typedef ::capnp::schemas::NodeDirection_f6bb46baa2f38621 NodeDirection;

struct Channel {
  Channel() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8281fc5fbc1ea1ce, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct XList {
  XList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a64dad11eeb08ba, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct YList {
  YList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(836f0f2555113268, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Timing {
  Timing() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(818068b4395469e9, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Sizing {
  Sizing() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3bca30e882428a5, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Switch {
  Switch() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b553ce463639a60b, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SegmentTiming {
  SegmentTiming() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d95894a0bc8ca56d, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Segment {
  Segment() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(adb5d2318fc1539f, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Pin {
  Pin() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f929c136e3d37192, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PinClass {
  PinClass() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab4c09b13574bfce, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Meta {
  Meta() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(951bee909a9d3d16, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata {
  Metadata() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b19cff100e3ab2bb, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockType {
  BlockType() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff25f299dad5c8f5, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GridLoc {
  GridLoc() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab54b0e5ced07cb0, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NodeLoc {
  NodeLoc() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b680b4b9c81fad46, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NodeTiming {
  NodeTiming() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bde08ceb25928e34, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NodeSegment {
  NodeSegment() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ba73370bd56eda71, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Node {
  Node() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c6833636198c9030, 2, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Edge {
  Edge() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f9804e6682a46e90, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Channels {
  Channels() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a156231d89499253, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Switches {
  Switches() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(98525d6e2fe65138, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Segments {
  Segments() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(961742a65e1df39a, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTypes {
  BlockTypes() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a38f0d830ee56ae4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GridLocs {
  GridLocs() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff494c402e780f12, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RrNodes {
  RrNodes() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b8fa642c9d0c2b0f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RrEdges {
  RrEdges() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9aa36e608dbaa408, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BinNodes {
  BinNodes() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bddada96d2721e78, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ConnectionBox {
  ConnectionBox() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f3fb1e46a7505145, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ConnectionBoxes {
  ConnectionBoxes() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(abcefd01f55032dd, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RrGraph {
  RrGraph() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ddca876b31278662, 0, 12)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Channel::Reader {
public:
  typedef Channel Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getChanWidthMax() const;

  inline  ::int32_t getXMax() const;

  inline  ::int32_t getXMin() const;

  inline  ::int32_t getYMax() const;

  inline  ::int32_t getYMin() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Channel::Builder {
public:
  typedef Channel Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getChanWidthMax();
  inline void setChanWidthMax( ::int32_t value);

  inline  ::int32_t getXMax();
  inline void setXMax( ::int32_t value);

  inline  ::int32_t getXMin();
  inline void setXMin( ::int32_t value);

  inline  ::int32_t getYMax();
  inline void setYMax( ::int32_t value);

  inline  ::int32_t getYMin();
  inline void setYMin( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Channel::Pipeline {
public:
  typedef Channel Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class XList::Reader {
public:
  typedef XList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex() const;

  inline  ::int32_t getInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class XList::Builder {
public:
  typedef XList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex();
  inline void setIndex( ::uint32_t value);

  inline  ::int32_t getInfo();
  inline void setInfo( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class XList::Pipeline {
public:
  typedef XList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class YList::Reader {
public:
  typedef YList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex() const;

  inline  ::int32_t getInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class YList::Builder {
public:
  typedef YList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex();
  inline void setIndex( ::uint32_t value);

  inline  ::int32_t getInfo();
  inline void setInfo( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class YList::Pipeline {
public:
  typedef YList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Timing::Reader {
public:
  typedef Timing Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getCin() const;

  inline float getCinternal() const;

  inline float getCout() const;

  inline float getR() const;

  inline float getTdel() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Timing::Builder {
public:
  typedef Timing Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getCin();
  inline void setCin(float value);

  inline float getCinternal();
  inline void setCinternal(float value);

  inline float getCout();
  inline void setCout(float value);

  inline float getR();
  inline void setR(float value);

  inline float getTdel();
  inline void setTdel(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Timing::Pipeline {
public:
  typedef Timing Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Sizing::Reader {
public:
  typedef Sizing Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getBufSize() const;

  inline float getMuxTransSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Sizing::Builder {
public:
  typedef Sizing Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getBufSize();
  inline void setBufSize(float value);

  inline float getMuxTransSize();
  inline void setMuxTransSize(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Sizing::Pipeline {
public:
  typedef Sizing Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Switch::Reader {
public:
  typedef Switch Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::SwitchType getType() const;

  inline bool hasTiming() const;
  inline  ::Timing::Reader getTiming() const;

  inline bool hasSizing() const;
  inline  ::Sizing::Reader getSizing() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Switch::Builder {
public:
  typedef Switch Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::SwitchType getType();
  inline void setType( ::SwitchType value);

  inline bool hasTiming();
  inline  ::Timing::Builder getTiming();
  inline void setTiming( ::Timing::Reader value);
  inline  ::Timing::Builder initTiming();
  inline void adoptTiming(::capnp::Orphan< ::Timing>&& value);
  inline ::capnp::Orphan< ::Timing> disownTiming();

  inline bool hasSizing();
  inline  ::Sizing::Builder getSizing();
  inline void setSizing( ::Sizing::Reader value);
  inline  ::Sizing::Builder initSizing();
  inline void adoptSizing(::capnp::Orphan< ::Sizing>&& value);
  inline ::capnp::Orphan< ::Sizing> disownSizing();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Switch::Pipeline {
public:
  typedef Switch Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Timing::Pipeline getTiming();
  inline  ::Sizing::Pipeline getSizing();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SegmentTiming::Reader {
public:
  typedef SegmentTiming Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getCPerMeter() const;

  inline float getRPerMeter() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SegmentTiming::Builder {
public:
  typedef SegmentTiming Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getCPerMeter();
  inline void setCPerMeter(float value);

  inline float getRPerMeter();
  inline void setRPerMeter(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SegmentTiming::Pipeline {
public:
  typedef SegmentTiming Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Segment::Reader {
public:
  typedef Segment Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasTiming() const;
  inline  ::SegmentTiming::Reader getTiming() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Segment::Builder {
public:
  typedef Segment Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasTiming();
  inline  ::SegmentTiming::Builder getTiming();
  inline void setTiming( ::SegmentTiming::Reader value);
  inline  ::SegmentTiming::Builder initTiming();
  inline void adoptTiming(::capnp::Orphan< ::SegmentTiming>&& value);
  inline ::capnp::Orphan< ::SegmentTiming> disownTiming();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Segment::Pipeline {
public:
  typedef Segment Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::SegmentTiming::Pipeline getTiming();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Pin::Reader {
public:
  typedef Pin Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPtc() const;

  inline bool hasValue() const;
  inline  ::capnp::Text::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Pin::Builder {
public:
  typedef Pin Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPtc();
  inline void setPtc( ::int32_t value);

  inline bool hasValue();
  inline  ::capnp::Text::Builder getValue();
  inline void setValue( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Pin::Pipeline {
public:
  typedef Pin Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PinClass::Reader {
public:
  typedef PinClass Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::PinType getType() const;

  inline bool hasPins() const;
  inline  ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>::Reader getPins() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PinClass::Builder {
public:
  typedef PinClass Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::PinType getType();
  inline void setType( ::PinType value);

  inline bool hasPins();
  inline  ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>::Builder getPins();
  inline void setPins( ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>::Builder initPins(unsigned int size);
  inline void adoptPins(::capnp::Orphan< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>> disownPins();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PinClass::Pipeline {
public:
  typedef PinClass Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Meta::Reader {
public:
  typedef Meta Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasValue() const;
  inline  ::capnp::Text::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Meta::Builder {
public:
  typedef Meta Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasValue();
  inline  ::capnp::Text::Builder getValue();
  inline void setValue( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Meta::Pipeline {
public:
  typedef Meta Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Reader {
public:
  typedef Metadata Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMetas() const;
  inline  ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>::Reader getMetas() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Builder {
public:
  typedef Metadata Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMetas();
  inline  ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>::Builder getMetas();
  inline void setMetas( ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>::Builder initMetas(unsigned int size);
  inline void adoptMetas(::capnp::Orphan< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>> disownMetas();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Pipeline {
public:
  typedef Metadata Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockType::Reader {
public:
  typedef BlockType Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getHeight() const;

  inline  ::int32_t getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::int32_t getWidth() const;

  inline bool hasPinClasses() const;
  inline  ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>::Reader getPinClasses() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockType::Builder {
public:
  typedef BlockType Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getHeight();
  inline void setHeight( ::int32_t value);

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::int32_t getWidth();
  inline void setWidth( ::int32_t value);

  inline bool hasPinClasses();
  inline  ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>::Builder getPinClasses();
  inline void setPinClasses( ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>::Builder initPinClasses(unsigned int size);
  inline void adoptPinClasses(::capnp::Orphan< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>> disownPinClasses();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockType::Pipeline {
public:
  typedef BlockType Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GridLoc::Reader {
public:
  typedef GridLoc Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getBlockTypeId() const;

  inline  ::int32_t getHeightOffset() const;

  inline  ::int32_t getWidthOffset() const;

  inline  ::int32_t getX() const;

  inline  ::int32_t getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GridLoc::Builder {
public:
  typedef GridLoc Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getBlockTypeId();
  inline void setBlockTypeId( ::int32_t value);

  inline  ::int32_t getHeightOffset();
  inline void setHeightOffset( ::int32_t value);

  inline  ::int32_t getWidthOffset();
  inline void setWidthOffset( ::int32_t value);

  inline  ::int32_t getX();
  inline void setX( ::int32_t value);

  inline  ::int32_t getY();
  inline void setY( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GridLoc::Pipeline {
public:
  typedef GridLoc Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NodeLoc::Reader {
public:
  typedef NodeLoc Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPtc() const;

  inline  ::LocSide getSide() const;

  inline  ::int32_t getXhigh() const;

  inline  ::int32_t getXlow() const;

  inline  ::int32_t getYhigh() const;

  inline  ::int32_t getYlow() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NodeLoc::Builder {
public:
  typedef NodeLoc Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPtc();
  inline void setPtc( ::int32_t value);

  inline  ::LocSide getSide();
  inline void setSide( ::LocSide value);

  inline  ::int32_t getXhigh();
  inline void setXhigh( ::int32_t value);

  inline  ::int32_t getXlow();
  inline void setXlow( ::int32_t value);

  inline  ::int32_t getYhigh();
  inline void setYhigh( ::int32_t value);

  inline  ::int32_t getYlow();
  inline void setYlow( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NodeLoc::Pipeline {
public:
  typedef NodeLoc Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NodeTiming::Reader {
public:
  typedef NodeTiming Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getC() const;

  inline float getR() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NodeTiming::Builder {
public:
  typedef NodeTiming Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getC();
  inline void setC(float value);

  inline float getR();
  inline void setR(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NodeTiming::Pipeline {
public:
  typedef NodeTiming Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NodeSegment::Reader {
public:
  typedef NodeSegment Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSegmentId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NodeSegment::Builder {
public:
  typedef NodeSegment Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSegmentId();
  inline void setSegmentId( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NodeSegment::Pipeline {
public:
  typedef NodeSegment Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Node::Reader {
public:
  typedef Node Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCapacity() const;

  inline  ::NodeDirection getDirection() const;

  inline  ::uint32_t getId() const;

  inline  ::NodeType getType() const;

  inline bool hasLoc() const;
  inline  ::NodeLoc::Reader getLoc() const;

  inline bool hasTiming() const;
  inline  ::NodeTiming::Reader getTiming() const;

  inline bool hasSegment() const;
  inline  ::NodeSegment::Reader getSegment() const;

  inline bool hasMetadata() const;
  inline  ::Metadata::Reader getMetadata() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::Builder {
public:
  typedef Node Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCapacity();
  inline void setCapacity( ::uint32_t value);

  inline  ::NodeDirection getDirection();
  inline void setDirection( ::NodeDirection value);

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline  ::NodeType getType();
  inline void setType( ::NodeType value);

  inline bool hasLoc();
  inline  ::NodeLoc::Builder getLoc();
  inline void setLoc( ::NodeLoc::Reader value);
  inline  ::NodeLoc::Builder initLoc();
  inline void adoptLoc(::capnp::Orphan< ::NodeLoc>&& value);
  inline ::capnp::Orphan< ::NodeLoc> disownLoc();

  inline bool hasTiming();
  inline  ::NodeTiming::Builder getTiming();
  inline void setTiming( ::NodeTiming::Reader value);
  inline  ::NodeTiming::Builder initTiming();
  inline void adoptTiming(::capnp::Orphan< ::NodeTiming>&& value);
  inline ::capnp::Orphan< ::NodeTiming> disownTiming();

  inline bool hasSegment();
  inline  ::NodeSegment::Builder getSegment();
  inline void setSegment( ::NodeSegment::Reader value);
  inline  ::NodeSegment::Builder initSegment();
  inline void adoptSegment(::capnp::Orphan< ::NodeSegment>&& value);
  inline ::capnp::Orphan< ::NodeSegment> disownSegment();

  inline bool hasMetadata();
  inline  ::Metadata::Builder getMetadata();
  inline void setMetadata( ::Metadata::Reader value);
  inline  ::Metadata::Builder initMetadata();
  inline void adoptMetadata(::capnp::Orphan< ::Metadata>&& value);
  inline ::capnp::Orphan< ::Metadata> disownMetadata();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::Pipeline {
public:
  typedef Node Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::NodeLoc::Pipeline getLoc();
  inline  ::NodeTiming::Pipeline getTiming();
  inline  ::NodeSegment::Pipeline getSegment();
  inline  ::Metadata::Pipeline getMetadata();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Edge::Reader {
public:
  typedef Edge Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getId() const;

  inline  ::uint32_t getSinkNode() const;

  inline  ::uint32_t getSrcNode() const;

  inline  ::uint32_t getSwitchId() const;

  inline bool hasMetadata() const;
  inline  ::Metadata::Reader getMetadata() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Edge::Builder {
public:
  typedef Edge Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline  ::uint32_t getSinkNode();
  inline void setSinkNode( ::uint32_t value);

  inline  ::uint32_t getSrcNode();
  inline void setSrcNode( ::uint32_t value);

  inline  ::uint32_t getSwitchId();
  inline void setSwitchId( ::uint32_t value);

  inline bool hasMetadata();
  inline  ::Metadata::Builder getMetadata();
  inline void setMetadata( ::Metadata::Reader value);
  inline  ::Metadata::Builder initMetadata();
  inline void adoptMetadata(::capnp::Orphan< ::Metadata>&& value);
  inline ::capnp::Orphan< ::Metadata> disownMetadata();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Edge::Pipeline {
public:
  typedef Edge Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Metadata::Pipeline getMetadata();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Channels::Reader {
public:
  typedef Channels Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasChannel() const;
  inline  ::Channel::Reader getChannel() const;

  inline bool hasXLists() const;
  inline  ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>::Reader getXLists() const;

  inline bool hasYLists() const;
  inline  ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>::Reader getYLists() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Channels::Builder {
public:
  typedef Channels Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasChannel();
  inline  ::Channel::Builder getChannel();
  inline void setChannel( ::Channel::Reader value);
  inline  ::Channel::Builder initChannel();
  inline void adoptChannel(::capnp::Orphan< ::Channel>&& value);
  inline ::capnp::Orphan< ::Channel> disownChannel();

  inline bool hasXLists();
  inline  ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>::Builder getXLists();
  inline void setXLists( ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>::Builder initXLists(unsigned int size);
  inline void adoptXLists(::capnp::Orphan< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>> disownXLists();

  inline bool hasYLists();
  inline  ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>::Builder getYLists();
  inline void setYLists( ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>::Builder initYLists(unsigned int size);
  inline void adoptYLists(::capnp::Orphan< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>> disownYLists();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Channels::Pipeline {
public:
  typedef Channels Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Channel::Pipeline getChannel();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Switches::Reader {
public:
  typedef Switches Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSwitches() const;
  inline  ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>::Reader getSwitches() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Switches::Builder {
public:
  typedef Switches Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSwitches();
  inline  ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>::Builder getSwitches();
  inline void setSwitches( ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>::Builder initSwitches(unsigned int size);
  inline void adoptSwitches(::capnp::Orphan< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>> disownSwitches();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Switches::Pipeline {
public:
  typedef Switches Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Segments::Reader {
public:
  typedef Segments Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSegments() const;
  inline  ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>::Reader getSegments() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Segments::Builder {
public:
  typedef Segments Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSegments();
  inline  ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>::Builder getSegments();
  inline void setSegments( ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>::Builder initSegments(unsigned int size);
  inline void adoptSegments(::capnp::Orphan< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>> disownSegments();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Segments::Pipeline {
public:
  typedef Segments Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTypes::Reader {
public:
  typedef BlockTypes Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBlockTypes() const;
  inline  ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>::Reader getBlockTypes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTypes::Builder {
public:
  typedef BlockTypes Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBlockTypes();
  inline  ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>::Builder getBlockTypes();
  inline void setBlockTypes( ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>::Builder initBlockTypes(unsigned int size);
  inline void adoptBlockTypes(::capnp::Orphan< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>> disownBlockTypes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTypes::Pipeline {
public:
  typedef BlockTypes Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GridLocs::Reader {
public:
  typedef GridLocs Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGridLocs() const;
  inline  ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>::Reader getGridLocs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GridLocs::Builder {
public:
  typedef GridLocs Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGridLocs();
  inline  ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>::Builder getGridLocs();
  inline void setGridLocs( ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>::Builder initGridLocs(unsigned int size);
  inline void adoptGridLocs(::capnp::Orphan< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>> disownGridLocs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GridLocs::Pipeline {
public:
  typedef GridLocs Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RrNodes::Reader {
public:
  typedef RrNodes Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNodes() const;
  inline  ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>::Reader getNodes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RrNodes::Builder {
public:
  typedef RrNodes Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNodes();
  inline  ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>::Builder getNodes();
  inline void setNodes( ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>::Builder initNodes(unsigned int size);
  inline void adoptNodes(::capnp::Orphan< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>> disownNodes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RrNodes::Pipeline {
public:
  typedef RrNodes Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RrEdges::Reader {
public:
  typedef RrEdges Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEdges() const;
  inline  ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>::Reader getEdges() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RrEdges::Builder {
public:
  typedef RrEdges Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEdges();
  inline  ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>::Builder getEdges();
  inline void setEdges( ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>::Builder initEdges(unsigned int size);
  inline void adoptEdges(::capnp::Orphan< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>> disownEdges();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RrEdges::Pipeline {
public:
  typedef RrEdges Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BinNodes::Reader {
public:
  typedef BinNodes Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFile() const;
  inline  ::capnp::Text::Reader getFile() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BinNodes::Builder {
public:
  typedef BinNodes Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFile();
  inline  ::capnp::Text::Builder getFile();
  inline void setFile( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFile(unsigned int size);
  inline void adoptFile(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFile();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BinNodes::Pipeline {
public:
  typedef BinNodes Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ConnectionBox::Reader {
public:
  typedef ConnectionBox Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ConnectionBox::Builder {
public:
  typedef ConnectionBox Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ConnectionBox::Pipeline {
public:
  typedef ConnectionBox Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ConnectionBoxes::Reader {
public:
  typedef ConnectionBoxes Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getNumBoxes() const;

  inline  ::int32_t getXDim() const;

  inline  ::int32_t getYDim() const;

  inline bool hasConnectionBoxes() const;
  inline  ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>::Reader getConnectionBoxes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ConnectionBoxes::Builder {
public:
  typedef ConnectionBoxes Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getNumBoxes();
  inline void setNumBoxes( ::uint32_t value);

  inline  ::int32_t getXDim();
  inline void setXDim( ::int32_t value);

  inline  ::int32_t getYDim();
  inline void setYDim( ::int32_t value);

  inline bool hasConnectionBoxes();
  inline  ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>::Builder getConnectionBoxes();
  inline void setConnectionBoxes( ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>::Builder initConnectionBoxes(unsigned int size);
  inline void adoptConnectionBoxes(::capnp::Orphan< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>> disownConnectionBoxes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ConnectionBoxes::Pipeline {
public:
  typedef ConnectionBoxes Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RrGraph::Reader {
public:
  typedef RrGraph Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasToolComment() const;
  inline  ::capnp::Text::Reader getToolComment() const;

  inline bool hasToolName() const;
  inline  ::capnp::Text::Reader getToolName() const;

  inline bool hasToolVersion() const;
  inline  ::capnp::Text::Reader getToolVersion() const;

  inline bool hasBinaryNodesAndEdges() const;
  inline  ::BinNodes::Reader getBinaryNodesAndEdges() const;

  inline bool hasConnectionBoxes() const;
  inline  ::ConnectionBoxes::Reader getConnectionBoxes() const;

  inline bool hasChannels() const;
  inline  ::Channels::Reader getChannels() const;

  inline bool hasSwitches() const;
  inline  ::Switches::Reader getSwitches() const;

  inline bool hasSegments() const;
  inline  ::Segments::Reader getSegments() const;

  inline bool hasBlockTypes() const;
  inline  ::BlockTypes::Reader getBlockTypes() const;

  inline bool hasGrid() const;
  inline  ::GridLocs::Reader getGrid() const;

  inline bool hasRrNodes() const;
  inline  ::RrNodes::Reader getRrNodes() const;

  inline bool hasRrEdges() const;
  inline  ::RrEdges::Reader getRrEdges() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RrGraph::Builder {
public:
  typedef RrGraph Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasToolComment();
  inline  ::capnp::Text::Builder getToolComment();
  inline void setToolComment( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initToolComment(unsigned int size);
  inline void adoptToolComment(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownToolComment();

  inline bool hasToolName();
  inline  ::capnp::Text::Builder getToolName();
  inline void setToolName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initToolName(unsigned int size);
  inline void adoptToolName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownToolName();

  inline bool hasToolVersion();
  inline  ::capnp::Text::Builder getToolVersion();
  inline void setToolVersion( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initToolVersion(unsigned int size);
  inline void adoptToolVersion(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownToolVersion();

  inline bool hasBinaryNodesAndEdges();
  inline  ::BinNodes::Builder getBinaryNodesAndEdges();
  inline void setBinaryNodesAndEdges( ::BinNodes::Reader value);
  inline  ::BinNodes::Builder initBinaryNodesAndEdges();
  inline void adoptBinaryNodesAndEdges(::capnp::Orphan< ::BinNodes>&& value);
  inline ::capnp::Orphan< ::BinNodes> disownBinaryNodesAndEdges();

  inline bool hasConnectionBoxes();
  inline  ::ConnectionBoxes::Builder getConnectionBoxes();
  inline void setConnectionBoxes( ::ConnectionBoxes::Reader value);
  inline  ::ConnectionBoxes::Builder initConnectionBoxes();
  inline void adoptConnectionBoxes(::capnp::Orphan< ::ConnectionBoxes>&& value);
  inline ::capnp::Orphan< ::ConnectionBoxes> disownConnectionBoxes();

  inline bool hasChannels();
  inline  ::Channels::Builder getChannels();
  inline void setChannels( ::Channels::Reader value);
  inline  ::Channels::Builder initChannels();
  inline void adoptChannels(::capnp::Orphan< ::Channels>&& value);
  inline ::capnp::Orphan< ::Channels> disownChannels();

  inline bool hasSwitches();
  inline  ::Switches::Builder getSwitches();
  inline void setSwitches( ::Switches::Reader value);
  inline  ::Switches::Builder initSwitches();
  inline void adoptSwitches(::capnp::Orphan< ::Switches>&& value);
  inline ::capnp::Orphan< ::Switches> disownSwitches();

  inline bool hasSegments();
  inline  ::Segments::Builder getSegments();
  inline void setSegments( ::Segments::Reader value);
  inline  ::Segments::Builder initSegments();
  inline void adoptSegments(::capnp::Orphan< ::Segments>&& value);
  inline ::capnp::Orphan< ::Segments> disownSegments();

  inline bool hasBlockTypes();
  inline  ::BlockTypes::Builder getBlockTypes();
  inline void setBlockTypes( ::BlockTypes::Reader value);
  inline  ::BlockTypes::Builder initBlockTypes();
  inline void adoptBlockTypes(::capnp::Orphan< ::BlockTypes>&& value);
  inline ::capnp::Orphan< ::BlockTypes> disownBlockTypes();

  inline bool hasGrid();
  inline  ::GridLocs::Builder getGrid();
  inline void setGrid( ::GridLocs::Reader value);
  inline  ::GridLocs::Builder initGrid();
  inline void adoptGrid(::capnp::Orphan< ::GridLocs>&& value);
  inline ::capnp::Orphan< ::GridLocs> disownGrid();

  inline bool hasRrNodes();
  inline  ::RrNodes::Builder getRrNodes();
  inline void setRrNodes( ::RrNodes::Reader value);
  inline  ::RrNodes::Builder initRrNodes();
  inline void adoptRrNodes(::capnp::Orphan< ::RrNodes>&& value);
  inline ::capnp::Orphan< ::RrNodes> disownRrNodes();

  inline bool hasRrEdges();
  inline  ::RrEdges::Builder getRrEdges();
  inline void setRrEdges( ::RrEdges::Reader value);
  inline  ::RrEdges::Builder initRrEdges();
  inline void adoptRrEdges(::capnp::Orphan< ::RrEdges>&& value);
  inline ::capnp::Orphan< ::RrEdges> disownRrEdges();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RrGraph::Pipeline {
public:
  typedef RrGraph Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::BinNodes::Pipeline getBinaryNodesAndEdges();
  inline  ::ConnectionBoxes::Pipeline getConnectionBoxes();
  inline  ::Channels::Pipeline getChannels();
  inline  ::Switches::Pipeline getSwitches();
  inline  ::Segments::Pipeline getSegments();
  inline  ::BlockTypes::Pipeline getBlockTypes();
  inline  ::GridLocs::Pipeline getGrid();
  inline  ::RrNodes::Pipeline getRrNodes();
  inline  ::RrEdges::Pipeline getRrEdges();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::int32_t Channel::Reader::getChanWidthMax() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getChanWidthMax() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setChanWidthMax( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Channel::Reader::getXMax() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getXMax() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setXMax( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Channel::Reader::getXMin() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getXMin() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setXMin( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Channel::Reader::getYMax() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getYMax() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setYMax( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Channel::Reader::getYMin() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getYMin() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setYMin( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t XList::Reader::getIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t XList::Builder::getIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void XList::Builder::setIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t XList::Reader::getInfo() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t XList::Builder::getInfo() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void XList::Builder::setInfo( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t YList::Reader::getIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t YList::Builder::getIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void YList::Builder::setIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t YList::Reader::getInfo() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t YList::Builder::getInfo() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void YList::Builder::setInfo( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Timing::Reader::getCin() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getCin() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setCin(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Timing::Reader::getCinternal() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getCinternal() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setCinternal(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Timing::Reader::getCout() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getCout() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setCout(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float Timing::Reader::getR() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getR() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setR(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float Timing::Reader::getTdel() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getTdel() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setTdel(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float Sizing::Reader::getBufSize() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Sizing::Builder::getBufSize() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Sizing::Builder::setBufSize(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Sizing::Reader::getMuxTransSize() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Sizing::Builder::getMuxTransSize() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Sizing::Builder::setMuxTransSize(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Switch::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Switch::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Switch::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Switch::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Switch::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Switch::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Switch::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Switch::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Switch::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Switch::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Switch::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::SwitchType Switch::Reader::getType() const {
  return _reader.getDataField< ::SwitchType>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::SwitchType Switch::Builder::getType() {
  return _builder.getDataField< ::SwitchType>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Switch::Builder::setType( ::SwitchType value) {
  _builder.setDataField< ::SwitchType>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Switch::Reader::hasTiming() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Switch::Builder::hasTiming() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Timing::Reader Switch::Reader::getTiming() const {
  return ::capnp::_::PointerHelpers< ::Timing>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Timing::Builder Switch::Builder::getTiming() {
  return ::capnp::_::PointerHelpers< ::Timing>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Timing::Pipeline Switch::Pipeline::getTiming() {
  return  ::Timing::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Switch::Builder::setTiming( ::Timing::Reader value) {
  ::capnp::_::PointerHelpers< ::Timing>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Timing::Builder Switch::Builder::initTiming() {
  return ::capnp::_::PointerHelpers< ::Timing>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Switch::Builder::adoptTiming(
    ::capnp::Orphan< ::Timing>&& value) {
  ::capnp::_::PointerHelpers< ::Timing>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Timing> Switch::Builder::disownTiming() {
  return ::capnp::_::PointerHelpers< ::Timing>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Switch::Reader::hasSizing() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Switch::Builder::hasSizing() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::Sizing::Reader Switch::Reader::getSizing() const {
  return ::capnp::_::PointerHelpers< ::Sizing>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::Sizing::Builder Switch::Builder::getSizing() {
  return ::capnp::_::PointerHelpers< ::Sizing>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Sizing::Pipeline Switch::Pipeline::getSizing() {
  return  ::Sizing::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Switch::Builder::setSizing( ::Sizing::Reader value) {
  ::capnp::_::PointerHelpers< ::Sizing>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::Sizing::Builder Switch::Builder::initSizing() {
  return ::capnp::_::PointerHelpers< ::Sizing>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Switch::Builder::adoptSizing(
    ::capnp::Orphan< ::Sizing>&& value) {
  ::capnp::_::PointerHelpers< ::Sizing>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Sizing> Switch::Builder::disownSizing() {
  return ::capnp::_::PointerHelpers< ::Sizing>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline float SegmentTiming::Reader::getCPerMeter() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float SegmentTiming::Builder::getCPerMeter() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SegmentTiming::Builder::setCPerMeter(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float SegmentTiming::Reader::getRPerMeter() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float SegmentTiming::Builder::getRPerMeter() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void SegmentTiming::Builder::setRPerMeter(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Segment::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Segment::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Segment::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Segment::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Segment::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Segment::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Segment::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Segment::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Segment::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Segment::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Segment::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Segment::Reader::hasTiming() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Segment::Builder::hasTiming() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::SegmentTiming::Reader Segment::Reader::getTiming() const {
  return ::capnp::_::PointerHelpers< ::SegmentTiming>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::SegmentTiming::Builder Segment::Builder::getTiming() {
  return ::capnp::_::PointerHelpers< ::SegmentTiming>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::SegmentTiming::Pipeline Segment::Pipeline::getTiming() {
  return  ::SegmentTiming::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Segment::Builder::setTiming( ::SegmentTiming::Reader value) {
  ::capnp::_::PointerHelpers< ::SegmentTiming>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::SegmentTiming::Builder Segment::Builder::initTiming() {
  return ::capnp::_::PointerHelpers< ::SegmentTiming>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Segment::Builder::adoptTiming(
    ::capnp::Orphan< ::SegmentTiming>&& value) {
  ::capnp::_::PointerHelpers< ::SegmentTiming>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::SegmentTiming> Segment::Builder::disownTiming() {
  return ::capnp::_::PointerHelpers< ::SegmentTiming>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int32_t Pin::Reader::getPtc() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Pin::Builder::getPtc() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Pin::Builder::setPtc( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Pin::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Pin::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Pin::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Pin::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Pin::Builder::setValue( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Pin::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Pin::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Pin::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::PinType PinClass::Reader::getType() const {
  return _reader.getDataField< ::PinType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::PinType PinClass::Builder::getType() {
  return _builder.getDataField< ::PinType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PinClass::Builder::setType( ::PinType value) {
  _builder.setDataField< ::PinType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PinClass::Reader::hasPins() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PinClass::Builder::hasPins() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>::Reader PinClass::Reader::getPins() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>::Builder PinClass::Builder::getPins() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PinClass::Builder::setPins( ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>::Builder PinClass::Builder::initPins(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PinClass::Builder::adoptPins(
    ::capnp::Orphan< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>> PinClass::Builder::disownPins() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Pin,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Meta::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Meta::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Meta::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Meta::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Meta::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Meta::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Meta::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Meta::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Meta::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Meta::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Meta::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Meta::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Meta::Builder::setValue( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Meta::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Meta::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Meta::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Metadata::Reader::hasMetas() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Builder::hasMetas() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>::Reader Metadata::Reader::getMetas() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>::Builder Metadata::Builder::getMetas() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Builder::setMetas( ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>::Builder Metadata::Builder::initMetas(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Builder::adoptMetas(
    ::capnp::Orphan< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>> Metadata::Builder::disownMetas() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Meta,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t BlockType::Reader::getHeight() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockType::Builder::getHeight() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockType::Builder::setHeight( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t BlockType::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockType::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BlockType::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool BlockType::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockType::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader BlockType::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder BlockType::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockType::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder BlockType::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockType::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> BlockType::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t BlockType::Reader::getWidth() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockType::Builder::getWidth() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BlockType::Builder::setWidth( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool BlockType::Reader::hasPinClasses() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BlockType::Builder::hasPinClasses() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>::Reader BlockType::Reader::getPinClasses() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>::Builder BlockType::Builder::getPinClasses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BlockType::Builder::setPinClasses( ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>::Builder BlockType::Builder::initPinClasses(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BlockType::Builder::adoptPinClasses(
    ::capnp::Orphan< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>> BlockType::Builder::disownPinClasses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PinClass,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int32_t GridLoc::Reader::getBlockTypeId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getBlockTypeId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setBlockTypeId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t GridLoc::Reader::getHeightOffset() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getHeightOffset() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setHeightOffset( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t GridLoc::Reader::getWidthOffset() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getWidthOffset() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setWidthOffset( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t GridLoc::Reader::getX() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getX() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setX( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t GridLoc::Reader::getY() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getY() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setY( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeLoc::Reader::getPtc() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getPtc() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setPtc( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::LocSide NodeLoc::Reader::getSide() const {
  return _reader.getDataField< ::LocSide>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::LocSide NodeLoc::Builder::getSide() {
  return _builder.getDataField< ::LocSide>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setSide( ::LocSide value) {
  _builder.setDataField< ::LocSide>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeLoc::Reader::getXhigh() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getXhigh() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setXhigh( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeLoc::Reader::getXlow() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getXlow() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setXlow( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeLoc::Reader::getYhigh() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getYhigh() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setYhigh( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeLoc::Reader::getYlow() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getYlow() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setYlow( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float NodeTiming::Reader::getC() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float NodeTiming::Builder::getC() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NodeTiming::Builder::setC(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float NodeTiming::Reader::getR() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float NodeTiming::Builder::getR() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void NodeTiming::Builder::setR(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeSegment::Reader::getSegmentId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeSegment::Builder::getSegmentId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NodeSegment::Builder::setSegmentId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Node::Reader::getCapacity() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Node::Builder::getCapacity() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setCapacity( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::NodeDirection Node::Reader::getDirection() const {
  return _reader.getDataField< ::NodeDirection>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::NodeDirection Node::Builder::getDirection() {
  return _builder.getDataField< ::NodeDirection>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setDirection( ::NodeDirection value) {
  _builder.setDataField< ::NodeDirection>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Node::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Node::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::NodeType Node::Reader::getType() const {
  return _reader.getDataField< ::NodeType>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::NodeType Node::Builder::getType() {
  return _builder.getDataField< ::NodeType>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setType( ::NodeType value) {
  _builder.setDataField< ::NodeType>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Reader::hasLoc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasLoc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::NodeLoc::Reader Node::Reader::getLoc() const {
  return ::capnp::_::PointerHelpers< ::NodeLoc>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::NodeLoc::Builder Node::Builder::getLoc() {
  return ::capnp::_::PointerHelpers< ::NodeLoc>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::NodeLoc::Pipeline Node::Pipeline::getLoc() {
  return  ::NodeLoc::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Node::Builder::setLoc( ::NodeLoc::Reader value) {
  ::capnp::_::PointerHelpers< ::NodeLoc>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::NodeLoc::Builder Node::Builder::initLoc() {
  return ::capnp::_::PointerHelpers< ::NodeLoc>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Node::Builder::adoptLoc(
    ::capnp::Orphan< ::NodeLoc>&& value) {
  ::capnp::_::PointerHelpers< ::NodeLoc>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::NodeLoc> Node::Builder::disownLoc() {
  return ::capnp::_::PointerHelpers< ::NodeLoc>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Node::Reader::hasTiming() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasTiming() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::NodeTiming::Reader Node::Reader::getTiming() const {
  return ::capnp::_::PointerHelpers< ::NodeTiming>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::NodeTiming::Builder Node::Builder::getTiming() {
  return ::capnp::_::PointerHelpers< ::NodeTiming>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::NodeTiming::Pipeline Node::Pipeline::getTiming() {
  return  ::NodeTiming::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Node::Builder::setTiming( ::NodeTiming::Reader value) {
  ::capnp::_::PointerHelpers< ::NodeTiming>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::NodeTiming::Builder Node::Builder::initTiming() {
  return ::capnp::_::PointerHelpers< ::NodeTiming>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Node::Builder::adoptTiming(
    ::capnp::Orphan< ::NodeTiming>&& value) {
  ::capnp::_::PointerHelpers< ::NodeTiming>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::NodeTiming> Node::Builder::disownTiming() {
  return ::capnp::_::PointerHelpers< ::NodeTiming>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Node::Reader::hasSegment() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasSegment() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::NodeSegment::Reader Node::Reader::getSegment() const {
  return ::capnp::_::PointerHelpers< ::NodeSegment>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::NodeSegment::Builder Node::Builder::getSegment() {
  return ::capnp::_::PointerHelpers< ::NodeSegment>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::NodeSegment::Pipeline Node::Pipeline::getSegment() {
  return  ::NodeSegment::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Node::Builder::setSegment( ::NodeSegment::Reader value) {
  ::capnp::_::PointerHelpers< ::NodeSegment>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::NodeSegment::Builder Node::Builder::initSegment() {
  return ::capnp::_::PointerHelpers< ::NodeSegment>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Node::Builder::adoptSegment(
    ::capnp::Orphan< ::NodeSegment>&& value) {
  ::capnp::_::PointerHelpers< ::NodeSegment>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::NodeSegment> Node::Builder::disownSegment() {
  return ::capnp::_::PointerHelpers< ::NodeSegment>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Node::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::Metadata::Reader Node::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers< ::Metadata>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::Metadata::Builder Node::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers< ::Metadata>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Metadata::Pipeline Node::Pipeline::getMetadata() {
  return  ::Metadata::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Node::Builder::setMetadata( ::Metadata::Reader value) {
  ::capnp::_::PointerHelpers< ::Metadata>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::Metadata::Builder Node::Builder::initMetadata() {
  return ::capnp::_::PointerHelpers< ::Metadata>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Node::Builder::adoptMetadata(
    ::capnp::Orphan< ::Metadata>&& value) {
  ::capnp::_::PointerHelpers< ::Metadata>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Metadata> Node::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers< ::Metadata>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::uint32_t Edge::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Edge::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Edge::Reader::getSinkNode() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Edge::Builder::getSinkNode() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setSinkNode( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Edge::Reader::getSrcNode() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Edge::Builder::getSrcNode() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setSrcNode( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Edge::Reader::getSwitchId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Edge::Builder::getSwitchId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setSwitchId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Edge::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Edge::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Metadata::Reader Edge::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers< ::Metadata>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Metadata::Builder Edge::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers< ::Metadata>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Metadata::Pipeline Edge::Pipeline::getMetadata() {
  return  ::Metadata::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Edge::Builder::setMetadata( ::Metadata::Reader value) {
  ::capnp::_::PointerHelpers< ::Metadata>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Metadata::Builder Edge::Builder::initMetadata() {
  return ::capnp::_::PointerHelpers< ::Metadata>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Edge::Builder::adoptMetadata(
    ::capnp::Orphan< ::Metadata>&& value) {
  ::capnp::_::PointerHelpers< ::Metadata>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Metadata> Edge::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers< ::Metadata>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Channels::Reader::hasChannel() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Channels::Builder::hasChannel() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Channel::Reader Channels::Reader::getChannel() const {
  return ::capnp::_::PointerHelpers< ::Channel>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Channel::Builder Channels::Builder::getChannel() {
  return ::capnp::_::PointerHelpers< ::Channel>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Channel::Pipeline Channels::Pipeline::getChannel() {
  return  ::Channel::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Channels::Builder::setChannel( ::Channel::Reader value) {
  ::capnp::_::PointerHelpers< ::Channel>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Channel::Builder Channels::Builder::initChannel() {
  return ::capnp::_::PointerHelpers< ::Channel>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Channels::Builder::adoptChannel(
    ::capnp::Orphan< ::Channel>&& value) {
  ::capnp::_::PointerHelpers< ::Channel>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Channel> Channels::Builder::disownChannel() {
  return ::capnp::_::PointerHelpers< ::Channel>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Channels::Reader::hasXLists() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Channels::Builder::hasXLists() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>::Reader Channels::Reader::getXLists() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>::Builder Channels::Builder::getXLists() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Channels::Builder::setXLists( ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>::Builder Channels::Builder::initXLists(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Channels::Builder::adoptXLists(
    ::capnp::Orphan< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>> Channels::Builder::disownXLists() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::XList,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Channels::Reader::hasYLists() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Channels::Builder::hasYLists() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>::Reader Channels::Reader::getYLists() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>::Builder Channels::Builder::getYLists() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Channels::Builder::setYLists( ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>::Builder Channels::Builder::initYLists(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Channels::Builder::adoptYLists(
    ::capnp::Orphan< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>> Channels::Builder::disownYLists() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::YList,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Switches::Reader::hasSwitches() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Switches::Builder::hasSwitches() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>::Reader Switches::Reader::getSwitches() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>::Builder Switches::Builder::getSwitches() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Switches::Builder::setSwitches( ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>::Builder Switches::Builder::initSwitches(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Switches::Builder::adoptSwitches(
    ::capnp::Orphan< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>> Switches::Builder::disownSwitches() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Switch,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Segments::Reader::hasSegments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Segments::Builder::hasSegments() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>::Reader Segments::Reader::getSegments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>::Builder Segments::Builder::getSegments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Segments::Builder::setSegments( ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>::Builder Segments::Builder::initSegments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Segments::Builder::adoptSegments(
    ::capnp::Orphan< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>> Segments::Builder::disownSegments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Segment,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTypes::Reader::hasBlockTypes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTypes::Builder::hasBlockTypes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>::Reader BlockTypes::Reader::getBlockTypes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>::Builder BlockTypes::Builder::getBlockTypes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTypes::Builder::setBlockTypes( ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>::Builder BlockTypes::Builder::initBlockTypes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTypes::Builder::adoptBlockTypes(
    ::capnp::Orphan< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>> BlockTypes::Builder::disownBlockTypes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::BlockType,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GridLocs::Reader::hasGridLocs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GridLocs::Builder::hasGridLocs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>::Reader GridLocs::Reader::getGridLocs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>::Builder GridLocs::Builder::getGridLocs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GridLocs::Builder::setGridLocs( ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>::Builder GridLocs::Builder::initGridLocs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void GridLocs::Builder::adoptGridLocs(
    ::capnp::Orphan< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>> GridLocs::Builder::disownGridLocs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::GridLoc,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RrNodes::Reader::hasNodes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RrNodes::Builder::hasNodes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>::Reader RrNodes::Reader::getNodes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>::Builder RrNodes::Builder::getNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RrNodes::Builder::setNodes( ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>::Builder RrNodes::Builder::initNodes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RrNodes::Builder::adoptNodes(
    ::capnp::Orphan< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>> RrNodes::Builder::disownNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Node,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RrEdges::Reader::hasEdges() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RrEdges::Builder::hasEdges() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>::Reader RrEdges::Reader::getEdges() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>::Builder RrEdges::Builder::getEdges() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RrEdges::Builder::setEdges( ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>::Builder RrEdges::Builder::initEdges(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RrEdges::Builder::adoptEdges(
    ::capnp::Orphan< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>> RrEdges::Builder::disownEdges() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Edge,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BinNodes::Reader::hasFile() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BinNodes::Builder::hasFile() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader BinNodes::Reader::getFile() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder BinNodes::Builder::getFile() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BinNodes::Builder::setFile( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder BinNodes::Builder::initFile(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BinNodes::Builder::adoptFile(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> BinNodes::Builder::disownFile() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t ConnectionBox::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t ConnectionBox::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ConnectionBox::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ConnectionBox::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ConnectionBox::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ConnectionBox::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ConnectionBox::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ConnectionBox::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ConnectionBox::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ConnectionBox::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ConnectionBox::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t ConnectionBoxes::Reader::getNumBoxes() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t ConnectionBoxes::Builder::getNumBoxes() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ConnectionBoxes::Builder::setNumBoxes( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ConnectionBoxes::Reader::getXDim() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ConnectionBoxes::Builder::getXDim() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ConnectionBoxes::Builder::setXDim( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ConnectionBoxes::Reader::getYDim() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ConnectionBoxes::Builder::getYDim() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ConnectionBoxes::Builder::setYDim( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool ConnectionBoxes::Reader::hasConnectionBoxes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ConnectionBoxes::Builder::hasConnectionBoxes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>::Reader ConnectionBoxes::Reader::getConnectionBoxes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>::Builder ConnectionBoxes::Builder::getConnectionBoxes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ConnectionBoxes::Builder::setConnectionBoxes( ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>::Builder ConnectionBoxes::Builder::initConnectionBoxes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ConnectionBoxes::Builder::adoptConnectionBoxes(
    ::capnp::Orphan< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>> ConnectionBoxes::Builder::disownConnectionBoxes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ConnectionBox,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasToolComment() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasToolComment() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RrGraph::Reader::getToolComment() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RrGraph::Builder::getToolComment() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::setToolComment( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RrGraph::Builder::initToolComment(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RrGraph::Builder::adoptToolComment(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RrGraph::Builder::disownToolComment() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasToolName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasToolName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RrGraph::Reader::getToolName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RrGraph::Builder::getToolName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::setToolName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RrGraph::Builder::initToolName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void RrGraph::Builder::adoptToolName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RrGraph::Builder::disownToolName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasToolVersion() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasToolVersion() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RrGraph::Reader::getToolVersion() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RrGraph::Builder::getToolVersion() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::setToolVersion( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RrGraph::Builder::initToolVersion(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void RrGraph::Builder::adoptToolVersion(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RrGraph::Builder::disownToolVersion() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasBinaryNodesAndEdges() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasBinaryNodesAndEdges() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::BinNodes::Reader RrGraph::Reader::getBinaryNodesAndEdges() const {
  return ::capnp::_::PointerHelpers< ::BinNodes>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::BinNodes::Builder RrGraph::Builder::getBinaryNodesAndEdges() {
  return ::capnp::_::PointerHelpers< ::BinNodes>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::BinNodes::Pipeline RrGraph::Pipeline::getBinaryNodesAndEdges() {
  return  ::BinNodes::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setBinaryNodesAndEdges( ::BinNodes::Reader value) {
  ::capnp::_::PointerHelpers< ::BinNodes>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::BinNodes::Builder RrGraph::Builder::initBinaryNodesAndEdges() {
  return ::capnp::_::PointerHelpers< ::BinNodes>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptBinaryNodesAndEdges(
    ::capnp::Orphan< ::BinNodes>&& value) {
  ::capnp::_::PointerHelpers< ::BinNodes>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::BinNodes> RrGraph::Builder::disownBinaryNodesAndEdges() {
  return ::capnp::_::PointerHelpers< ::BinNodes>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasConnectionBoxes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasConnectionBoxes() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::ConnectionBoxes::Reader RrGraph::Reader::getConnectionBoxes() const {
  return ::capnp::_::PointerHelpers< ::ConnectionBoxes>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::ConnectionBoxes::Builder RrGraph::Builder::getConnectionBoxes() {
  return ::capnp::_::PointerHelpers< ::ConnectionBoxes>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ConnectionBoxes::Pipeline RrGraph::Pipeline::getConnectionBoxes() {
  return  ::ConnectionBoxes::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setConnectionBoxes( ::ConnectionBoxes::Reader value) {
  ::capnp::_::PointerHelpers< ::ConnectionBoxes>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::ConnectionBoxes::Builder RrGraph::Builder::initConnectionBoxes() {
  return ::capnp::_::PointerHelpers< ::ConnectionBoxes>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptConnectionBoxes(
    ::capnp::Orphan< ::ConnectionBoxes>&& value) {
  ::capnp::_::PointerHelpers< ::ConnectionBoxes>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ConnectionBoxes> RrGraph::Builder::disownConnectionBoxes() {
  return ::capnp::_::PointerHelpers< ::ConnectionBoxes>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasChannels() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasChannels() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::Channels::Reader RrGraph::Reader::getChannels() const {
  return ::capnp::_::PointerHelpers< ::Channels>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::Channels::Builder RrGraph::Builder::getChannels() {
  return ::capnp::_::PointerHelpers< ::Channels>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Channels::Pipeline RrGraph::Pipeline::getChannels() {
  return  ::Channels::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setChannels( ::Channels::Reader value) {
  ::capnp::_::PointerHelpers< ::Channels>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::Channels::Builder RrGraph::Builder::initChannels() {
  return ::capnp::_::PointerHelpers< ::Channels>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptChannels(
    ::capnp::Orphan< ::Channels>&& value) {
  ::capnp::_::PointerHelpers< ::Channels>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Channels> RrGraph::Builder::disownChannels() {
  return ::capnp::_::PointerHelpers< ::Channels>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasSwitches() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasSwitches() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::Switches::Reader RrGraph::Reader::getSwitches() const {
  return ::capnp::_::PointerHelpers< ::Switches>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::Switches::Builder RrGraph::Builder::getSwitches() {
  return ::capnp::_::PointerHelpers< ::Switches>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Switches::Pipeline RrGraph::Pipeline::getSwitches() {
  return  ::Switches::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setSwitches( ::Switches::Reader value) {
  ::capnp::_::PointerHelpers< ::Switches>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::Switches::Builder RrGraph::Builder::initSwitches() {
  return ::capnp::_::PointerHelpers< ::Switches>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptSwitches(
    ::capnp::Orphan< ::Switches>&& value) {
  ::capnp::_::PointerHelpers< ::Switches>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Switches> RrGraph::Builder::disownSwitches() {
  return ::capnp::_::PointerHelpers< ::Switches>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasSegments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasSegments() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::Segments::Reader RrGraph::Reader::getSegments() const {
  return ::capnp::_::PointerHelpers< ::Segments>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::Segments::Builder RrGraph::Builder::getSegments() {
  return ::capnp::_::PointerHelpers< ::Segments>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Segments::Pipeline RrGraph::Pipeline::getSegments() {
  return  ::Segments::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setSegments( ::Segments::Reader value) {
  ::capnp::_::PointerHelpers< ::Segments>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::Segments::Builder RrGraph::Builder::initSegments() {
  return ::capnp::_::PointerHelpers< ::Segments>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptSegments(
    ::capnp::Orphan< ::Segments>&& value) {
  ::capnp::_::PointerHelpers< ::Segments>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Segments> RrGraph::Builder::disownSegments() {
  return ::capnp::_::PointerHelpers< ::Segments>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasBlockTypes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasBlockTypes() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::BlockTypes::Reader RrGraph::Reader::getBlockTypes() const {
  return ::capnp::_::PointerHelpers< ::BlockTypes>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::BlockTypes::Builder RrGraph::Builder::getBlockTypes() {
  return ::capnp::_::PointerHelpers< ::BlockTypes>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::BlockTypes::Pipeline RrGraph::Pipeline::getBlockTypes() {
  return  ::BlockTypes::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setBlockTypes( ::BlockTypes::Reader value) {
  ::capnp::_::PointerHelpers< ::BlockTypes>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::BlockTypes::Builder RrGraph::Builder::initBlockTypes() {
  return ::capnp::_::PointerHelpers< ::BlockTypes>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptBlockTypes(
    ::capnp::Orphan< ::BlockTypes>&& value) {
  ::capnp::_::PointerHelpers< ::BlockTypes>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::BlockTypes> RrGraph::Builder::disownBlockTypes() {
  return ::capnp::_::PointerHelpers< ::BlockTypes>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasGrid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasGrid() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::GridLocs::Reader RrGraph::Reader::getGrid() const {
  return ::capnp::_::PointerHelpers< ::GridLocs>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::GridLocs::Builder RrGraph::Builder::getGrid() {
  return ::capnp::_::PointerHelpers< ::GridLocs>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::GridLocs::Pipeline RrGraph::Pipeline::getGrid() {
  return  ::GridLocs::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setGrid( ::GridLocs::Reader value) {
  ::capnp::_::PointerHelpers< ::GridLocs>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::GridLocs::Builder RrGraph::Builder::initGrid() {
  return ::capnp::_::PointerHelpers< ::GridLocs>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptGrid(
    ::capnp::Orphan< ::GridLocs>&& value) {
  ::capnp::_::PointerHelpers< ::GridLocs>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::GridLocs> RrGraph::Builder::disownGrid() {
  return ::capnp::_::PointerHelpers< ::GridLocs>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasRrNodes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasRrNodes() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::RrNodes::Reader RrGraph::Reader::getRrNodes() const {
  return ::capnp::_::PointerHelpers< ::RrNodes>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline  ::RrNodes::Builder RrGraph::Builder::getRrNodes() {
  return ::capnp::_::PointerHelpers< ::RrNodes>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::RrNodes::Pipeline RrGraph::Pipeline::getRrNodes() {
  return  ::RrNodes::Pipeline(_typeless.getPointerField(10));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setRrNodes( ::RrNodes::Reader value) {
  ::capnp::_::PointerHelpers< ::RrNodes>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::RrNodes::Builder RrGraph::Builder::initRrNodes() {
  return ::capnp::_::PointerHelpers< ::RrNodes>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptRrNodes(
    ::capnp::Orphan< ::RrNodes>&& value) {
  ::capnp::_::PointerHelpers< ::RrNodes>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::RrNodes> RrGraph::Builder::disownRrNodes() {
  return ::capnp::_::PointerHelpers< ::RrNodes>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasRrEdges() const {
  return !_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasRrEdges() {
  return !_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline  ::RrEdges::Reader RrGraph::Reader::getRrEdges() const {
  return ::capnp::_::PointerHelpers< ::RrEdges>::get(_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline  ::RrEdges::Builder RrGraph::Builder::getRrEdges() {
  return ::capnp::_::PointerHelpers< ::RrEdges>::get(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::RrEdges::Pipeline RrGraph::Pipeline::getRrEdges() {
  return  ::RrEdges::Pipeline(_typeless.getPointerField(11));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setRrEdges( ::RrEdges::Reader value) {
  ::capnp::_::PointerHelpers< ::RrEdges>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline  ::RrEdges::Builder RrGraph::Builder::initRrEdges() {
  return ::capnp::_::PointerHelpers< ::RrEdges>::init(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptRrEdges(
    ::capnp::Orphan< ::RrEdges>&& value) {
  ::capnp::_::PointerHelpers< ::RrEdges>::adopt(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::RrEdges> RrGraph::Builder::disownRrEdges() {
  return ::capnp::_::PointerHelpers< ::RrEdges>::disown(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}


